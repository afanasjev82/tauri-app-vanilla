
Project Overview
Name: Tauri web app example
Description: 
Tauri app that opens a pre-specified URL in the default system browser and persists own state between sessions.

Example web application (client) requirements:
- The client should be able to open a pre-specified default URL and read the URL from the command line. 
- The client's app state should be stored in a file located in the user's home directory. 

Objectives: 
- Example web app should be able to read the URL from the command line and store app state in a file located in the user's home directory

Deliverables:
- Example application for Windows that can open a pre-specified URL when run, and persist own state in a file
- Documentation on how to build and run the example client
- The source code for the project

2. Requirements

Functional Requirements:
- Builded client should be able to open a pre-specified URL from command line
- Builded client should be able to store app state (cookies, window location, etc) in a file located in the user's home directory.

Non-functional Requirements:
- The system should be built in isolated environment using Dockerfile

Worklog:

1.day
In our exmaple web app case Tauri layer provides API for iteractiong with Windows OS. 
As tauri app frontend is WebView instance manager

The plan: 
0. Tauri build and debug environment setup (https://tauri.app/v1/guides/debugging/vs-code)
1. Get familiarize with the Tauri framework (tools, build and debug process, WebView2)
2. Create lightweight client that meets the requirements directly on the host OS (Windows 11).
3. Wrap client build process in a container using Docker
4. Test building process with Docker under different host OS (Windows, Windows WSL, Ubuntu, MacOS)
5. Test builded client under different host OS

The initial assumption is to split development process into 2 parts: 
1. Build example client application that met the requirements directly on host OS (Windows)
2. Build receipt in form of Dockerfile that is able to build tauri web app clients executable files for Windows (x86_64)

[tauri-app] Initial assumption was to build tauri app client which fontend is based on React. 
Tauri build process builds React application client and bundles it with WebView2 instance created on startup.

Thus, you can separate the process of launching a web application and the rest of the functionality:
- saving and restoring the state, for example through localStorage (appWindow.onMoved, appWindow.onResized, etc)
- change window.location.url
- loading splashscreen like "loading..."
- assumption: localStorage is transparently mapped by Tauri to WebView2 UDF (webview.set_user_data_folder) - need to check.

Thus, Tauri will assemble a nesting "matryoshka" doll where the core is the web application and the shell is the WebView2 
component and the glue between them is in form of "@tauri/api" package

However, this method has its advantages and disadvantages:
1. It is possible to explicitly save data in files using the @tauri-apps/api library API ("path" module). 
Thus, it is possible to save the state of the application between working sessions.
2. However, there is a problem in the form of collecting all possible state paratters (with the size and 
position of the window is simple, but with cookies, cache, and other structures that WebView2 uses - it will be more difficult)

[tauri-app-vanulla] Alternative solution was to implement all functional requirements through tauri (backend) using Rust. 
I've found plugin for saving tauri window state "tauri-plugin-window-state", but at this moment i'm not sure is it's saving all 
the state using file in host OS used home directory, need to check that.

However, this method has its advantages and disadvantages:
1. There is a "tauri-plugin-window-state" plugin that saves all the necessary information and does not need to be collected, 
saved (when the application is closed) and restored (when the application is reopened) - the plugin does everything on its own.
2. However, even here there are details. An instance of the WebView2 class of the tauri UDF application. 
WebView2 applications use User Data Folders (UDFs) to store browser data such as cookies, permissions, and cached resources.
The "tauri-plugin-window-state" plugin uses the Tauri api folder and the path.appConfigDir() module function to store the 
application's window state structure:

struct WindowState {
    width: f64,
    height: f64,
    x: i32,
    y: i32,
    maximized: bool,
    visible: bool,
    decorated: bool,
    fullscreen: bool,
}

"path.appConfigDir()" resolves to ${configDir}/${bundleIdentifier} where bundleIdentifier is the value that tauri.bundle.identifier 
is configured in tauri.conf.json and ${configDir} resolves to $XDG_CONFIG_HOME or $HOME/.config.

The WebView2 instance stores state in the default UDF folder. The default path to the UDF folder 
of the WebView2 component can be changed using the WEBVIEW2_USER_DATA_FOLDER environment variable which should be set 
in tauri backend before tauri app (and default webview2 instance) initialization.

Due to heuristic programming strategy used in current workflow I'm tried both approaches and due to limited requirements 
set for example application client and will stick to the second vanilla approach [tauri-app-vanilla]

Command line arguments

[--url]
We have several ways to set the URL to open later for a Tauri-based application. The easiest way is the tauri application 
window config (WindowConfig) (src-tauri/tauri.conf.json) "tauri > windows[0] > url". 
However, this cannot be done dynamically (from the command line of the compiled application) (as it seems to me now) - 
only during (or before) the application build, for example, through the ARG of the Dockerfile build process.

We have following requirement: 
"Write a Dockerfile that builds a tauri client for windows that, when run, 
opens a pre-specified URL. It should read the URL from command line"

To satisfy this requirement, you need to read the command line argument when the application starts and inject the url 
into the webview during the start and application process.

It's even better to make the "url" command line argument optional, and if there is no value, no changes will be made to the webview. 
Thus, the default url from tauri.conf.json will be used, which can be changed manually or during the build process of the 
application in the Docker container.


================================================================================================================================
[TODO]
1. config tauri.allowList in tauri.conf.json (AllowlistConfig)
2. config webviewInstallMode in WindowsConfig
3. use GNU compiler instead of Windows
4. Dockerfile: use rust:alpine image

cargo tauri build --debug
cargo tauri dev -- -- https://google.com