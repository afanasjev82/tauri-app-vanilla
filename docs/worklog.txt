
Project Overview
Name: Tauri web app example
Description: 
Tauri app that opens a pre-specified URL in the default system browser and persists own state between sessions.

Example web application (client) requirements:
- The client should be able to open a pre-specified default URL and read the URL from the command line. 
- The client's app state should be stored in a file located in the user's home directory. 

Objectives: 
- Example web app should be able to read the URL from the command line and store app state in a file located in the user's home directory

Deliverables:
- Example application for Windows that can open a pre-specified URL when run, and persist own state in a file
- Documentation on how to build and run the example client
- The source code for the project

2. Requirements

Functional Requirements:
- Builded client should be able to open a pre-specified URL from command line
- Builded client should be able to store app state (cookies, window location, etc) in a file located in the user's home directory.

Non-functional Requirements:
- The system should be built in isolated environment using Dockerfile


3. Design
- WebView2 - default embedded web content renderer in Windows environment (win7+)
- Tauri - Tauri is a framework for building desktop applications using web technologies such as HTML,
    CSS, and JavaScript. Tauri will be used to build the client, and its APIs will be used to interact 
	with the system and store app state in a file located in the user's home directory.
- Command line interface - The command line interface will be responsible for reading the URL from the command line and 
	passing it to the Tauri application. This will enable the user to specify the URL that the client should open when it is run.
- User home directory - The user home directory will be used to store the app state generated by the client. 
	This will allow the client to remember user preferences and settings between sessions.
- Windows executable - The final output of the build process will be a Windows executable 
	file that can be run on a Windows machine to launch the Tauri client.


Worklog:

1.day
In our exmaple web app case Tauri layer provides API for iteractiong with Windows OS. 
As tauri app frontend is WebView instance manager

The plan: 
0. Tauri build and debug environment setup (https://tauri.app/v1/guides/debugging/vs-code)
1. Get familiarize with the Tauri framework (tools, build and debug process, WebView2)
2. Create lightweight client that meets the requirements directly on the host OS (Windows 11).
3. Wrap client build process in a container using Docker
4. Test building process with Docker under different host OS (Windows, Windows WSL, Ubuntu, MacOS)
5. Test builded client under different host OS

The initial assumption is to split development process into 2 parts: 
1. Build example client application that met the requirements directly on host OS (Windows)
2. Build receipt in form of Dockerfile that is able to build tauri web app clients executable files for Windows (x86_64)

[tauri-app] Initial assumption was to build tauri app client which fontend is based on React. 
Tauri build process builds React application client and bundles it with WebView2 instance created on startup.

Thus, you can separate the process of launching a web application and the rest of the functionality:
- saving and restoring the state, for example through localStorage (appWindow.onMoved, appWindow.onResized, etc)
- change window.location.url
- loading splashscreen like "loading..."
- assumption: localStorage is transparently mapped by Tauri to WebView2 UDF (webview.set_user_data_folder) - need to check.

Thus, Tauri will assemble a nesting "matryoshka" doll where the core is the web application and the shell is the WebView2 
component and the glue between them is in form of "@tauri/api" package

However, this method has its advantages and disadvantages:
1. It is possible to explicitly save data in files using the @tauri-apps/api library API ("path" module). 
Thus, it is possible to save the state of the application between working sessions.
2. However, there is a problem in the form of collecting all possible state paratters (with the size and 
position of the window is simple, but with cookies, cache, and other structures that WebView2 uses - it will be more difficult)

[tauri-app-vanulla] Alternative solution was to implement all functional requirements through tauri (backend) using Rust. 
I've found plugin for saving tauri window state "tauri-plugin-window-state", but at this moment i'm not sure is it's saving all 
the state using file in host OS used home directory, need to check that.

However, this method has its advantages and disadvantages:
1. There is a "tauri-plugin-window-state" plugin that saves all the necessary information and does not need to be collected, 
saved (when the application is closed) and restored (when the application is reopened) - the plugin does everything on its own.
2. However, even here there are details. An instance of the WebView2 class of the tauri UDF application. 
WebView2 applications use User Data Folders (UDFs) to store browser data such as cookies, permissions, and cached resources.
The "tauri-plugin-window-state" plugin uses the Tauri api folder and the path.appConfigDir() module function to store the 
application's window state structure:

struct WindowState {
    width: f64,
    height: f64,
    x: i32,
    y: i32,
    maximized: bool,
    visible: bool,
    decorated: bool,
    fullscreen: bool,
}

"path.appConfigDir()" resolves to ${configDir}/${bundleIdentifier} where bundleIdentifier is the value that tauri.bundle.identifier 
is configured in tauri.conf.json and ${configDir} resolves to $XDG_CONFIG_HOME or $HOME/.config.

The WebView2 instance stores state in the default UDF folder. The default path to the UDF folder 
of the WebView2 component can be changed using the WEBVIEW2_USER_DATA_FOLDER environment variable which should be set 
in tauri backend before tauri app (and default webview2 instance) initialization.

Due to heuristic programming strategy used in current workflow I'm tried both approaches and due to limited requirements 
set for example application client and will stick to the second vanilla approach [tauri-app-vanilla]

[feature] URL

We have several ways to set the URL to open later for a Tauri-based application. The easiest way is the tauri application 
window config (WindowConfig) (src-tauri/tauri.conf.json) "tauri > windows[0] > url". 
However, this cannot be done dynamically (from the command line of the compiled application) (as it seems to me now) - 
only during (or before) the application build, for example, through the ARG of the Dockerfile build process.

We have following requirement: 
"Write a Dockerfile that builds a tauri client for windows that, when run, 
opens a pre-specified URL. It should read the URL from command line"

To satisfy this requirement, you need to read the command line argument when the application starts and inject the url 
into the webview during the start and application process.

It's even better to make the "url" command line argument optional, and if there is no value, no changes will be made to the webview. 
Thus, the default url from tauri.conf.json will be used, which can be changed manually or during the build process of the 
application in the Docker container.

[tauri-app-builder] ================================================================================================================

Project Overview
Name: Tauri app builder
Description: 
The Tauri Web app client builder project aims to create a Dockerfile that compile Tauri lightweight web apps (clients) for Windows.  

Project requirements:
- Create a watertight "recipe" for building lightweight web app clients that can be easily compiled using a Dockerfile.
    - The build process should be done in isolated environment
    - Docker container host OS during the build process is not limited to Windows
    - The output of build process should be Windows executable file
 
The project's primary goal is to create a watertight "recipe" for building lightweight web app clients that can be easily
compiled using a Dockerfile. Builded container should be as "factory of executables": tauri-app source as input and builded 
Windows executable as output.

Objectives: 
- Create Docekrfile that builds a web application for Windows using Tauri framework
- The project build process will not involve using online services for compilation or assuming that the host OS is Windows

Deliverables:
- A Dockerfile for compiling the lightweight web app using Tauri framework 
- Documentation on how to build the "factory" container and build tauri client using that "factory"
- The source code for the project


Functional Requirements:
- The system should be able to compile a lightweight web app client using a Dockerfile despite the host OS.

Non-functional Requirements:
- The system should be built in isolated environment using Dockerfile
- The build process should not use online services for compilation and not assume that the host OS is Windows.

3. Design
- Dockerfile - The Dockerfile will be responsible for compiling the Tauri client for Windows. 
	The Dockerfile will include all the necessary dependencies and build tools required to compile 
	the client from source code.
- Windows executable - The final output of the build process will be a Windows executable 
	file that can be run on a Windows machine to launch the Tauri client.

At this stage, you need to pack the steps for setting up the environment and the build process of the executable file 
from the source code of the tauri application in a Dockerfile. The main difficulty is setting up a corssplatform 
toolchain for compiling and building inside an isolated container environment. Since I settled on the MinGW compiler 
and linker, you need to add them to the environment before starting the build phase. 
All other ingredients of the "recipe" are already familiar with the process of building the Tauri application in host OS

As best practice I use multistage container build process: 
    1. build executable from source
    2. copy builded windows executable file from bilder stage to docker volume shared with host OS

Known limitations:
[WebView2Loader.dll]

A binary library WebView2Loader from the WebView2 SDK need to be used, either the DLL WebView2Loader.dll or the static library 
WebView2LoaderStatic.lib. 

This brings some complexities:
* When using the msvc toolchain, the static library is used. 
* When using the gnu toolchain, the static library does not seem to work so the WebView2Loader.dll DLL is used. 
    You need to make sure that the DLL can be loaded at runtime, e.g. by putting it alongside the built exe files.

Docker linux containers should be used because rust:latest docker images does not have windows/amd64 support.
Dockerfile builder stage moved rust: alpine dokcer image

#TODO =============================================================================================================================
1. config tauri.allowList in tauri.conf.json (AllowlistConfig)
2. config webviewInstallMode in WindowsConfig
3. use GNU compiler instead of Windows
4. Dockerfile: use rust:alpine image

cargo tauri build --debug
cargo tauri dev -- -- https://google.com



docker build --build-arg DEFAULT_URL=https://neti.ee -f Dockerfile -t afanasjev/tauri-app-builder:latest .
docker run -v E:\Work\JaanTallinn\tauri-web-client\tauri-app-vanilla\release:/app/release afanasjev/tauri-app-builder:latest