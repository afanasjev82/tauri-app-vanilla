
Project Overview
Name: Tauri Web App Client Builder
Description: 
The Tauri Web App Client Builder project aims to create a Dockerfile that compile lightweight web apps (clients) for Windows 
using Tauri framework.  

Example web application (client) requirements:
* The client should be able to open a pre-specified URL and read the URL from the command line. 
* The client's app state should be stored in a file located in the user's home directory. 
 
The project's primary goal is to create a watertight "recipe" for building lightweight web app clients that can be easily
compiled using a Dockerfile.

Objectives: 
* Create Docekrfile that builds a web application for Windows using Tauri framework
* The project build process will not involve using online services for compilation or assuming that the host OS is Windows
* Example web application (client) should be able to read the URL from the command line and store app state
in a file located in the user's home directory

Deliverables:
* A Dockerfile for compiling the lightweight web app using Tauri framework 
* Example application for Windows that can open a pre-specified URL when run, and persist own state in a file
* Documentation on how to build and run the example client
* The source code for the project

2. Requirements

Functional Requirements:
2.1.1. The system should be able to compile a lightweight web app client using a Dockerfile despite the host OS.
2.1.2. Builded client should be able to open a pre-specified URL from command line
2.1.3. Builded client should be able to store app state (cookies, window location, etc) in a file located in the user's home directory.

Non-functional Requirements:
2.2.1. The system should be built in isolated environment using Dockerfile
2.2.2. The build process should not use online services for compilation and not assume that the host OS is Windows.

3. Design
3.1 Dockerfile - The Dockerfile will be responsible for compiling the Tauri client for Windows. 
	The Dockerfile will include all the necessary dependencies and build tools required to compile 
	the client from source code.
3.2 Tauri - Tauri is a framework for building desktop applications using web technologies such as HTML,
 	CSS, and JavaScript. Tauri will be used to build the client, and its APIs will be used to interact 
	with the system and store app state in a file located in the user's home directory.
3.3 Command line interface - The command line interface will be responsible for reading the URL from the command line and 
	passing it to the Tauri application. This will enable the user to specify the URL that the client should open when it is run.
3.4 User home directory - The user home directory will be used to store the app state generated by the client. 
	This will allow the client to remember user preferences and settings between sessions.
3.5 Windows executable - The final output of the build process will be a Windows executable 
	file that can be run on a Windows machine to launch the Tauri client.


Worklog:

1.day
In our exmaple web app case Tauri layer provides API for iteractiong with Windows OS. 
As tauri app frontend is WebView instance manager

The plan: 
0. Tauri build and debug environment setup (https://tauri.app/v1/guides/debugging/vs-code)
1. Get familiarize with the Tauri framework (tools, build and debug process, WebView2)
2. Create lightweight client that meets the requirements directly on the host OS (Windows 11).
3. Wrap client build process in a container using Docker
4. Test building process with Docker under different host OS (Windows, Windows WSL, Ubuntu, MacOS)
5. Test builded client under different host OS

The initial assumption is to split development process into 2 parts: 
1. Build example client application that met the requirements directly on host OS (Windows)
2. Build receipt in form of Dockerfile that is able to build tauri web app clients executable files for Windows (x86_64)

[tauri-app] Initial assumption was to build tauri app client which fontend is based on React. 
Tauri build process builds React application client and bundles it with WebView2 instance created on startup.

Thus, you can separate the process of launching a web application and the rest of the functionality:
* saving and restoring the state, for example through localStorage (appWindow.onMoved, appWindow.onResized, etc)
* change window.location.url
* loading splashscreen like "loading..."
* assumption: localStorage is transparently mapped by Tauri to WebView2 UDF (webview.set_user_data_folder) - need to check.

Thus, Tauri will assemble a nesting "matryoshka" doll where the core is the web application and the shell is the WebView2 
component and the glue between them is in form of "@tauri/api" package

However, this method has its advantages and disadvantages:
1. It is possible to explicitly save data in files using the @tauri-apps/api library API ("path" module). 
Thus, it is possible to save the state of the application between working sessions.
2. However, there is a problem in the form of collecting all possible state paratters (with the size and 
position of the window is simple, but with cookies, cache, and other structures that WebView2 uses - it will be more difficult)

[tauri-app-vanulla] Alternative solution was to implement all functional requirements through tauri (backend) using Rust. 
I've found plugin for saving tauri window state "tauri-plugin-window-state", but at this moment i'm not sure is it's saving all 
the state using file in host OS used home directory, need to check that.

However, this method has its advantages and disadvantages:
1. There is a "tauri-plugin-window-state" plugin that saves all the necessary information and does not need to be collected, 
saved (when the application is closed) and restored (when the application is reopened) - the plugin does everything on its own.
2. However, even here there are details. An instance of the WebView2 class of the tauri UDF application. 
WebView2 applications use User Data Folders (UDFs) to store browser data such as cookies, permissions, and cached resources.
The "tauri-plugin-window-state" plugin uses the Tauri api folder and the path.appConfigDir() module function to store the 
application's window state structure:

struct WindowState {
    width: f64,
    height: f64,
    x: i32,
    y: i32,
    maximized: bool,
    visible: bool,
    decorated: bool,
    fullscreen: bool,
}

"path.appConfigDir()" resolves to ${configDir}/${bundleIdentifier} where bundleIdentifier is the value that tauri.bundle.identifier 
is configured in tauri.conf.json and ${configDir} resolves to $XDG_CONFIG_HOME or $HOME/.config.

The WebView2 instance stores state in the default UDF folder. The default path to the UDF folder 
of the WebView2 component can be changed using the WEBVIEW2_USER_DATA_FOLDER environment variable which should be set 
in tauri backend before tauri app (and default webview2 instance) initialization.

Due to heuristic programming strategy used in current workflow I'm tried both approaches and due to limited requirements 
set for example application client and will stick to the second vanilla approach [tauri-app-vanilla]

[feature] URL

We have several ways to set the URL to open later for a Tauri-based application. The easiest way is the tauri application 
window config (WindowConfig) (src-tauri/tauri.conf.json) "tauri > windows[0] > url". 
However, this cannot be done dynamically (from the command line of the compiled application) (as it seems to me now) - 
only during (or before) the application build, for example, through the ARG of the Dockerfile build process.

We have following requirement: 
"Write a Dockerfile that builds a tauri client for windows that, when run, 
opens a pre-specified URL. It should read the URL from command line"

To satisfy this requirement, you need to read the command line argument when the application starts and inject the url 
into the webview during the start and application process.

It's even better to make the "url" command line argument optional, and if there is no value, no changes will be made to the webview. 
Thus, the default url from tauri.conf.json will be used, which can be changed manually or during the build process of the 
application in the Docker container.


#TODO =============================================================================================================================
1. config tauri.allowList in tauri.conf.json (AllowlistConfig)
2. config webviewInstallMode in WindowsConfig

cargo tauri build --debug
cargo tauri dev -- -- https://google.com